#!/usr/bin/perl
use strict;
use warnings;

my $lastScanFile = "/tmp/wscan-last";
my $dev = `ifdev wlan`;
chomp $dev;
my $winfoExec = 'winfo';

my $usage = "Usage:\n"
  . "$0 [--now] [--retry] [--pretty|--ssids]\n"
  . "  perform a scan immediately\n"
  . "$0 -l|--last [--pretty|--ssids]\n"
  . "  print results of last scan\n"
  . "$0 <DELAY_INT> [--retry] [--pretty|--ssids]\n"
  . "  perform a scan only if last scan is <DELAY_INT> seconds old\n"
  . "\n"
  . "--pretty prints in human-readable table {default}\n"
  . "--ssids prints one ssid per line and nothing else\n"
  . "--retry retries every second forever until a scan is successful\n"
;

sub parseCell($);
sub trimPad($$);

sub cellSort($$){
  my ($a, $b) = @_;
  return (0
    or $$a{ENCRYPTION} cmp $$b{ENCRYPTION}
    or ($$b{QUALITY}=~/(\d+)/)[0] <=> ($$a{QUALITY}=~/(\d+)/)[0]
    or $$a{SSID} cmp $$b{SSID}
  );
}

sub scanNow($){
  my $retry = shift;
  system "sudo ifconfig $dev up";
  my $iwlist;
  do{
    $iwlist = `sudo iwlist $dev scan`;
    $retry = 0 if $? == 0;
    sleep 1 if $retry;
  }while($retry);
  
  exit 1 if $? != 0;
  if($iwlist =~ s/^$dev\s*Scan completed :\n//){
    open FH, "> $lastScanFile";
    print FH $iwlist;
    close FH;
  }
  return $iwlist;
}
sub scanLast(){
  return `cat $lastScanFile`;
}
sub scanRecent($$){
  my $delay = shift;
  my $retry = shift;
  my $scanDate = 0;
  if(-e $lastScanFile){
    $scanDate = `stat --format %Y $lastScanFile`;
    chomp $scanDate;
    $scanDate = 0 if not $scanDate =~ /^\d+$/;
  }else{
    print STDERR "no previous scan exists, scanning...\n";
    return scanNow $retry;
  }
  my $now = `date +%s`;
  my $elapsed = $now - $scanDate;
  print STDERR "last scan is ${elapsed}s old; ";
  if($elapsed > $delay){
    print STDERR "exceeds the limit of ${delay}s, rescanning...\n";
    return scanNow $retry;
  }else{
    print STDERR "within limit of ${delay}s, skipping scan\n";
    return scanLast;
  }
  exit 0;
}

sub main(@){
  my $iwlist;
  my $format = '--pretty';
  if(@_ > 0 and $_[-1] =~ /^(--pretty|--ssids)$/){
    $format = pop;
  }

  my $retry = 0;
  if(@_ > 0 and $_[-1] =~ /^--retry$/){
    $retry = 1;
    pop;
  }

  
  my $sched = shift;
  $sched = '--now' if not defined $sched;

  die $usage if @_ > 0;
  if($sched eq '--now'){
    $iwlist = scanNow $retry;
  }elsif($sched =~ /^(-l|--last)$/ and $retry == 0){
    $iwlist = scanLast;
  }elsif($sched =~ /^\d+$/){
    $iwlist = scanRecent $sched, $retry;
  }else{
    die $usage;
  }

  printScan $iwlist, $format;
}

sub printScan($$){
  my $iwlist = shift;
  my $format = shift;

  my @cells = split /          Cell \d+ - /, $iwlist;
  shift @cells;

  my @parsedCells = map {parseCell $_} @cells;

  @parsedCells = sort {cellSort $a, $b} @parsedCells;
  if($format eq '--pretty'){
    my %auto = map {chomp; s/^(\d+)://; $_ => $1} `$winfoExec --list-auto`;
    my %all = map {chomp; $_ => 1} `$winfoExec --list-all`;

    for my $cell(@parsedCells){
      my $info = '';
      if(defined $auto{$$cell{SSID}}){
        $info = "[$auto{$$cell{SSID}}]";
      }elsif(defined $all{$$cell{SSID}}){
        $info = '--'
      }
      print trimPad($$cell{SSID},       20) . " | " .
            trimPad($$cell{QUALITY},     4) . " | " .
            trimPad($$cell{ENCRYPTION},  4) . " | " .
            trimPad($info,               5) . "\n";
    }
  }elsif($format eq '--ssids'){
    for my $cell(@parsedCells){
      print "$$cell{SSID}\n";
    }
  }
}

sub parseCell($){
  my $cell = shift;
  $cell =~ /\s*ESSID:"(.*)"/;
  my $essid = $1;
  $cell =~ /\s*Quality=(\d+)\/(\d+)/;
  my $quality = $2 == 0 ? '?' : int($1*100/$2)."%";
  $cell =~ /\s*Encryption key:(.*)/;
  my $enc = '?';
  if($1 eq 'on'){
    if($cell =~ /WPA2/){
      $enc = 'WPA2';
    }elsif($cell =~ /WPA/){
      $enc = 'WPA';
    }else{
      $enc = 'WEP';
    }
  }else{
    $enc = 'NONE';
  }
  return {
    SSID => $essid,
    QUALITY => $quality,
    ENCRYPTION => $enc,
  };
}

sub trimPad($$){
  my ($s, $l) = @_;
  if(length $s > $l){
    $s = substr($s, 0, $l-2) . "..";
  }
  return $s . ' 'x($l - length $s);
}

&main(@ARGV);
